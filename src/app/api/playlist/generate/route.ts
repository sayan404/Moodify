import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { options } from "../../auth/[...nextauth]/options";

const GEMINI_API_KEY = process.env.GEMINI_API_KEY!;

export async function POST(request: Request) {
  console.log("[AI-Playlist] Start request");
  const session = await getServerSession(options);
  console.log("session from playlist route", session);
  console.log("[AI-Playlist] Session from playlist route:", session ? {
    user: session.user,
    accessToken: session.accessToken ? 'Present' : 'Missing',
  } : 'No session');

  if (!session?.user || !session.accessToken) {
    console.log("[AI-Playlist] Unauthorized");
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await request.json();
  const { moodText, description, mood, numSongs } = body;
  console.log("[AI-Playlist] User input:", { moodText, description, mood, numSongs });
  if (!moodText) {
    console.log("[AI-Playlist] No mood text provided");
    return NextResponse.json({ error: "Mood text is required" }, { status: 400 });
  }

  // 1. Call Gemini Flash for analysis
  const geminiPrompt = `
    Analyze the following user input and extract:
    - mood (e.g. happy, sad, energetic, nostalgic, etc.)
    - genre (e.g. pop, bollywood, rock, etc.)
    - era/decade (e.g. 90s, 2000s, etc.)
    - theme (e.g. love, party, workout, etc.)
    - up to ${numSongs || 5} song suggestions (title and artist, preferably with Spotify popularity)
    User input: "${moodText}"
    ${mood ? `Explicit mood: ${mood}` : ""}
    ${description ? `Playlist description: ${description}` : ""}
    Respond as JSON:
    {
      "mood": "...",
      "genre": "...",
      "era": "...",
      "theme": "...",
      "suggested_songs": [
        {"title": "...", "artist": "..."},
        ...
      ]
    }
  `;
  console.log("[AI-Playlist] Gemini prompt:", geminiPrompt);

  const geminiRes = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=" + GEMINI_API_KEY, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      contents: [{ parts: [{ text: geminiPrompt }] }]
    }),
  });
  console.log("[AI-Playlist] Gemini API status:", geminiRes.status);
  const geminiData = await geminiRes.json();
  console.log("[AI-Playlist] Gemini API response:", geminiData);
  const geminiText = geminiData.candidates?.[0]?.content?.parts?.[0]?.text || geminiData.candidates?.[0]?.content?.text || "";
  let aiResult;
  try {
    // Remove code block markers if present
    const cleaned = geminiText.replace(/```json|```/g, '').trim();
    aiResult = JSON.parse(cleaned);
    console.log("[AI-Playlist] Gemini AI result:", aiResult);
  } catch {
    console.log("[AI-Playlist] Gemini response parse error:", geminiText);
    return NextResponse.json({ error: "Gemini response parse error", raw: geminiText }, { status: 500 });
  }

  // 2. Search Spotify for each suggested song
  const foundTracks: { id: string, uri: string, name: string, artists: string[], albumName: string, duration: number }[] = [];
  for (const song of aiResult.suggested_songs || []) {
    const q = encodeURIComponent(`${song.title} ${song.artist}`);
    console.log("[AI-Playlist] Searching Spotify for:", song.title, "by", song.artist);
    const searchRes = await fetch(`https://api.spotify.com/v1/search?q=${q}&type=track&limit=1`, {
      headers: { Authorization: `Bearer ${session.accessToken}` }
    });
    console.log("[AI-Playlist] Spotify search status:", searchRes.status);
    const searchData = await searchRes.json();
    console.log("[AI-Playlist] Spotify search data:", searchData);
    const track = searchData.tracks?.items?.[0];
    if (track) {
      foundTracks.push({
        id: track.id,
        uri: track.uri,
        name: track.name,
        artists: track.artists.map((a: any) => a.name),
        albumName: track.album?.name ?? "",
        duration: track.duration_ms ?? 0,
      });
      console.log("[AI-Playlist] Found track:", track.name, "by", track.artists.map((a: any) => a.name).join(", "));
    } else {
      console.log("[AI-Playlist] No track found for:", song.title, song.artist);
    }
  }

  if (foundTracks.length === 0) {
    console.log("[AI-Playlist] No tracks found from AI suggestions", aiResult);
    return NextResponse.json({ error: "No tracks found from AI suggestions", aiResult }, { status: 404 });
  }

  // 3. Create a playlist
  console.log("[AI-Playlist] Creating playlist for user:", session.user.id);
  const playlistRes = await fetch(`https://api.spotify.com/v1/users/${session.user.id}/playlists`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${session.accessToken}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      name: `AI Playlist: ${aiResult.mood || aiResult.theme || "Your Mood"}`,
      description: description || `Generated by Gemini AI: ${moodText}`,
      public: false
    })
  });
  console.log("[AI-Playlist] Playlist creation status:", playlistRes.status);
  const playlistData = await playlistRes.json();
  console.log("[AI-Playlist] Playlist data:", playlistData);

  // Add error handling for playlist creation
  if (!playlistData.id) {
    console.log("[AI-Playlist] Failed to create playlist:", playlistData);
    return NextResponse.json({ error: "Failed to create playlist", details: playlistData }, { status: playlistRes.status });
  }

  // 4. Add tracks to the playlist
  console.log("[AI-Playlist] Adding tracks to playlist:", foundTracks.map(t => t.uri));
  const addTracksRes = await fetch(`https://api.spotify.com/v1/playlists/${playlistData.id}/tracks`, {
    method: "POST",
    headers: { Authorization: `Bearer ${session.accessToken}`, "Content-Type": "application/json" },
    body: JSON.stringify({ uris: foundTracks.map(t => t.uri) })
  });
  console.log("[AI-Playlist] Add tracks status:", addTracksRes.status);
  const addTracksData = await addTracksRes.json();
  console.log("[AI-Playlist] Add tracks response:", addTracksData);

  // --- Save playlist and tracks to DB ---
  try {
    const { PrismaClient } = await import("@prisma/client");
    const prisma = new PrismaClient();

    // First, ensure user exists in DB
    console.log("[AI-Playlist] Ensuring user exists in DB:", session.user.id);
    const user = await prisma.user.upsert({
      where: { spotifyId: session.user.id },
      update: {
        name: session.user.name || null,
        email: session.user.email || "",
        accessToken: session.accessToken,
      },
      create: {
        id: session.user.id,
        spotifyId: session.user.id,
        name: session.user.name || null,
        email: session.user.email || "",
        accessToken: session.accessToken,
        refreshToken: "", // We'll handle refresh token separately
      },
    });
    console.log("[AI-Playlist] User upserted:", user.id);

    // Now create the playlist
    console.log("[AI-Playlist] Creating playlist in DB");
    const dbPlaylist = await prisma.playlist.create({
      data: {
        name: playlistData.name,
        spotifyPlaylistId: playlistData.id,
        sentiment: mood || aiResult.mood || aiResult.theme || null,
        description: description || `Generated by Gemini AI: ${moodText}`,
        userId: user.id, // Use the user.id from the upserted user
        tracks: {
          create: foundTracks.map(track => ({
            spotifyId: track.id,
            name: track.name,
            artists: track.artists,
            albumName: track.albumName,
            duration: track.duration,
          }))
        }
      },
      include: { tracks: true }
    });
    console.log("[AI-Playlist] Playlist created in DB:", dbPlaylist.id);

    return NextResponse.json({
      playlist: {
        id: playlistData.id,
        dbPlaylistId: dbPlaylist.id,
        name: playlistData.name,
        url: playlistData.external_urls.spotify,
        tracks: foundTracks,
        mood: mood || aiResult.mood || aiResult.theme || null,
      },
      aiResult
    });

  } catch (err) {
    console.error("[AI-Playlist] Error saving playlist to DB:", err);
    // Still return the Spotify playlist even if DB save fails
    return NextResponse.json({
      playlist: {
        id: playlistData.id,
        name: playlistData.name,
        url: playlistData.external_urls.spotify,
        tracks: foundTracks,
        mood: mood || aiResult.mood || aiResult.theme || null,
      },
      aiResult,
      dbError: "Failed to save to database, but playlist was created on Spotify"
    });
  }
}


// 2025-07-22T16:58:39.070Z [info] [AI-Playlist] Start request
// 2025-07-22T16:58:39.072Z [info] session from session callback {
//   user: {
//     name: 'Sayan',
//     email: 'sayanmajumder0002@gmail.com',
//     image: undefined
//   },
//   expires: '2025-08-21T16:58:39.071Z',
//   accessToken: 'BQBhK2CRnRKmKHrOF2Jvk-NxTPPyW7BNVHQnWYbFxiOFthLXwkYoxYjVCX_WMXLu1exF_d7Cnqx07QJIH3lnTOFcJ2i2hg8PHD98oHGBJ9JWJW4wjMOYxO62MwuWqbbguqf_daBrqN3MmqL0cjTc3bb7OmAKVHsdbiyOFFljmxLTIhXIiZJfSYih_a32hEnIEUNe3MoSxYyNyZtxGarFgJD_TS44wbByrt2KymiroTchXbonDb0j8_UXp1lYmZwDQz_OFAzeNXo4TNiyxQZMUEY1IZ9A0esRexvc5PD4GI4vkFv3r3d2vfOm'
// }
// 2025-07-22T16:58:39.073Z [info] token from session callback {
//   name: 'Sayan',
//   email: 'sayanmajumder0002@gmail.com',
//   sub: '31qmncm3sxkyz7gnhinosohyuzki',
//   accessToken: 'BQBhK2CRnRKmKHrOF2Jvk-NxTPPyW7BNVHQnWYbFxiOFthLXwkYoxYjVCX_WMXLu1exF_d7Cnqx07QJIH3lnTOFcJ2i2hg8PHD98oHGBJ9JWJW4wjMOYxO62MwuWqbbguqf_daBrqN3MmqL0cjTc3bb7OmAKVHsdbiyOFFljmxLTIhXIiZJfSYih_a32hEnIEUNe3MoSxYyNyZtxGarFgJD_TS44wbByrt2KymiroTchXbonDb0j8_UXp1lYmZwDQz_OFAzeNXo4TNiyxQZMUEY1IZ9A0esRexvc5PD4GI4vkFv3r3d2vfOm',
//   refreshToken: 'AQBgWS-0y5iFjFegh8Dd6HPnLdHAvASMk_UBzR7qSUHW3KC6NDMZC2R0oG8ivl4Xes27uWqeEwK-KH3pyJc7TQsc7XDAvrI7s5PWUq32aYy42zIHe2fGfvaeJpRZPH5tXbs',
//   accessTokenExpires: 1753206563110,
//   iat: 1753203497,
//   exp: 1755795497,
//   jti: '5dbb3c0a-8563-4b3e-99d4-c7d0e865b56a'
// }
// 2025-07-22T16:58:39.089Z [info] session from playlist route {
//   user: {
//     name: 'Sayan',
//     email: 'sayanmajumder0002@gmail.com',
//     image: undefined,
//     id: '31qmncm3sxkyz7gnhinosohyuzki'
//   },
//   accessToken: 'BQBhK2CRnRKmKHrOF2Jvk-NxTPPyW7BNVHQnWYbFxiOFthLXwkYoxYjVCX_WMXLu1exF_d7Cnqx07QJIH3lnTOFcJ2i2hg8PHD98oHGBJ9JWJW4wjMOYxO62MwuWqbbguqf_daBrqN3MmqL0cjTc3bb7OmAKVHsdbiyOFFljmxLTIhXIiZJfSYih_a32hEnIEUNe3MoSxYyNyZtxGarFgJD_TS44wbByrt2KymiroTchXbonDb0j8_UXp1lYmZwDQz_OFAzeNXo4TNiyxQZMUEY1IZ9A0esRexvc5PD4GI4vkFv3r3d2vfOm'
// }
// 2025-07-22T16:58:39.089Z [info] [AI-Playlist] Session from playlist route: {
//   user: {
//     name: 'Sayan',
//     email: 'sayanmajumder0002@gmail.com',
//     image: undefined,
//     id: '31qmncm3sxkyz7gnhinosohyuzki'
//   },
//   accessToken: 'Present'
// }
// 2025-07-22T16:58:39.089Z [info] [AI-Playlist] User input: create a soothing music playlst for sleep
// 2025-07-22T16:58:39.089Z [info] [AI-Playlist] Gemini prompt: 
//     Analyze the following user input and extract:
//     - mood (e.g. happy, sad, energetic, nostalgic, etc.)
//     - genre (e.g. pop, bollywood, rock, etc.)
//     - era/decade (e.g. 90s, 2000s, etc.)
//     - theme (e.g. love, party, workout, etc.)
//     - up to 5 song suggestions (title and artist, preferably with Spotify popularity)
//     User input: "create a soothing music playlst for sleep"
//     Respond as JSON:
//     {
//       "mood": "...",
//       "genre": "...",
//       "era": "...",
//       "theme": "...",
//       "suggested_songs": [
//         {"title": "...", "artist": "..."},
//         ...
//       ]
//     }
// 2025-07-22T16:58:41.174Z [info] [AI-Playlist] Spotify search status: 200
// 2025-07-22T16:58:41.176Z [info] [AI-Playlist] Spotify search data: {
//   tracks: {
//     href: 'https://api.spotify.com/v1/search?offset=0&limit=1&query=Nuvole%20Bianche%20Ludovico%20Einaudi&type=track&locale=*',
//     limit: 1,
//     next: 'https://api.spotify.com/v1/search?offset=1&limit=1&query=Nuvole%20Bianche%20Ludovico%20Einaudi&type=track&locale=*',
//     offset: 0,
//     previous: null,
//     total: 1000,
//     items: [ [Object] ]
//   }
// }
// 2025-07-22T16:58:41.176Z [info] [AI-Playlist] Found track: Nuvole Bianche by Ludovico Einaudi
// 2025-07-22T16:58:41.176Z [info] [AI-Playlist] Searching Spotify for: Watermark by Enya
// 2025-07-22T16:58:41.547Z [info] [AI-Playlist] Spotify search status: 200
// 2025-07-22T16:58:41.550Z [info] [AI-Playlist] Spotify search data: {
//   tracks: {
//     href: 'https://api.spotify.com/v1/search?offset=0&limit=1&query=Watermark%20Enya&type=track&locale=*',
//     limit: 1,
//     next: 'https://api.spotify.com/v1/search?offset=1&limit=1&query=Watermark%20Enya&type=track&locale=*',
//     offset: 0,
//     previous: null,
//     total: 1000,
//     items: [ [Object] ]
//   }
// }
// 2025-07-22T16:58:41.550Z [info] [AI-Playlist] Found track: Watermark - 2009 Remaster by Enya
// 2025-07-22T16:58:41.550Z [info] [AI-Playlist] Searching Spotify for: An Ending (Ascent) by Brian Eno
// 2025-07-22T16:58:41.925Z [info] [AI-Playlist] Spotify search status: 200
// 2025-07-22T16:58:41.926Z [info] [AI-Playlist] Spotify search data: {
//   tracks: {
//     href: 'https://api.spotify.com/v1/search?offset=0&limit=1&query=An%20Ending%20%28Ascent%29%20Brian%20Eno&type=track&locale=*',
//     limit: 1,
//     next: 'https://api.spotify.com/v1/search?offset=1&limit=1&query=An%20Ending%20%28Ascent%29%20Brian%20Eno&type=track&locale=*',
//     offset: 0,
//     previous: null,
//     total: 1000,
//     items: [ [Object] ]
//   }
// }
// 2025-07-22T16:58:41.927Z [info] [AI-Playlist] Found track: An Ending (Ascent) - Remastered 2005 by Brian Eno
// 2025-07-22T16:58:41.927Z [info] [AI-Playlist] Searching Spotify for: Clair de Lune, L. 32 by Claude Debussy
// 2025-07-22T16:58:40.439Z [info] [AI-Playlist] Gemini API status: 200
// 2025-07-22T16:58:40.442Z [info] [AI-Playlist] Gemini API response: {
//   candidates: [
//     {
//       content: [Object],
//       finishReason: 'STOP',
//       avgLogprobs: -0.04094664904536033
//     }
//   ],
//   usageMetadata: {
//     promptTokenCount: 190,
//     candidatesTokenCount: 147,
//     totalTokenCount: 337,
//     promptTokensDetails: [ [Object] ],
//     candidatesTokensDetails: [ [Object] ]
//   },
//   modelVersion: 'gemini-2.0-flash',
//   responseId: 'P8N_aL3KDf-ygLUPh6XfgAE'
// }
// 2025-07-22T16:58:40.443Z [info] [AI-Playlist] Gemini AI result: {
//   mood: 'soothing',
//   genre: 'ambient',
//   era: 'any',
//   theme: 'sleep',
//   suggested_songs: [
//     { title: 'Weightless', artist: 'Marconi Union' },
//     { title: 'Nuvole Bianche', artist: 'Ludovico Einaudi' },
//     { title: 'Watermark', artist: 'Enya' },
//     { title: 'An Ending (Ascent)', artist: 'Brian Eno' },
//     { title: 'Clair de Lune, L. 32', artist: 'Claude Debussy' }
//   ]
// }
// 2025-07-22T16:58:40.443Z [info] [AI-Playlist] Searching Spotify for: Weightless by Marconi Union
// 2025-07-22T16:58:40.826Z [info] [AI-Playlist] Spotify search status: 200
// 2025-07-22T16:58:40.828Z [info] [AI-Playlist] Spotify search data: {
//   tracks: {
//     href: 'https://api.spotify.com/v1/search?offset=0&limit=1&query=Weightless%20Marconi%20Union&type=track&locale=*',
//     limit: 1,
//     next: 'https://api.spotify.com/v1/search?offset=1&limit=1&query=Weightless%20Marconi%20Union&type=track&locale=*',
//     offset: 0,
//     previous: null,
//     total: 998,
//     items: [ [Object] ]
//   }
// }
// 2025-07-22T16:58:40.829Z [info] [AI-Playlist] Found track: Weightless by Marconi Union
// 2025-07-22T16:58:40.829Z [info] [AI-Playlist] Searching Spotify for: Nuvole Bianche by Ludovico Einaudi
// 2025-07-22T16:58:42.335Z [info] [AI-Playlist] Spotify search status: 200
// 2025-07-22T16:58:42.338Z [info] [AI-Playlist] Spotify search data: {
//   tracks: {
//     href: 'https://api.spotify.com/v1/search?offset=0&limit=1&query=Clair%20de%20Lune%2C%20L.%2032%20Claude%20Debussy&type=track&locale=*',
//     limit: 1,
//     next: 'https://api.spotify.com/v1/search?offset=1&limit=1&query=Clair%20de%20Lune%2C%20L.%2032%20Claude%20Debussy&type=track&locale=*',
//     offset: 0,
//     previous: null,
//     total: 1000,
//     items: [ [Object] ]
//   }
// }
// 2025-07-22T16:58:42.338Z [info] [AI-Playlist] Found track: Clair de Lune, L. 32 by Claude Debussy, Martin Jones
// 2025-07-22T16:58:42.338Z [info] [AI-Playlist] Creating playlist for user: 31qmncm3sxkyz7gnhinosohyuzki
// 2025-07-22T16:58:42.467Z [info] [AI-Playlist] Playlist creation status: 201
// 2025-07-22T16:58:42.469Z [info] [AI-Playlist] Playlist data: {
//   collaborative: false,
//   description: 'Generated by Gemini AI: create a soothing music playlst for sleep',
//   external_urls: {
//     spotify: 'https://open.spotify.com/playlist/6FQUq5NDpF5eHo2zsLmbUR'
//   },
//   followers: { href: null, total: 0 },
//   href: 'https://api.spotify.com/v1/playlists/6FQUq5NDpF5eHo2zsLmbUR',
//   id: '6FQUq5NDpF5eHo2zsLmbUR',
//   images: [],
//   primary_color: null,
//   name: 'AI Playlist: soothing',
//   type: 'playlist',
//   uri: 'spotify:playlist:6FQUq5NDpF5eHo2zsLmbUR',
//   owner: {
//     href: 'https://api.spotify.com/v1/users/31qmncm3sxkyz7gnhinosohyuzki',
//     id: '31qmncm3sxkyz7gnhinosohyuzki',
//     type: 'user',
//     uri: 'spotify:user:31qmncm3sxkyz7gnhinosohyuzki',
//     display_name: null,
//     external_urls: {
//       spotify: 'https://open.spotify.com/user/31qmncm3sxkyz7gnhinosohyuzki'
//     }
//   },
//   public: false,
//   snapshot_id: 'AAAAFKKHYNIkst7fOK3X9A2l4DOUjoCR',
//   tracks: {
//     limit: 100,
//     next: null,
//     offset: 0,
//     previous: null,
//     href: 'https://api.spotify.com/v1/playlists/6FQUq5NDpF5eHo2zsLmbUR/tracks',
//     total: 0,
//     items: []
//   }
// }
// 2025-07-22T16:58:42.469Z [info] [AI-Playlist] Adding tracks to playlist: [
//   'spotify:track:6kkwzB6hXLIONkEk9JciA6',
//   'spotify:track:3weNRklVDqb4Rr5MhKBR3D',
//   'spotify:track:2XkWsVewOXOhSwWCQx2tR8',
//   'spotify:track:1vgSaC0BPlL6LEm4Xsx59J',
//   'spotify:track:5u5aVJKjSMJr4zesMPz7bL'
// ]
// 2025-07-22T16:58:42.598Z [info] [AI-Playlist] Add tracks status: 201
// 2025-07-22T16:58:42.600Z [info] [AI-Playlist] Add tracks response: { snapshot_id: 'AAAAAgwsxreqRUCGcnjYKyPo07zNRNUE' }